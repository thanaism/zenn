---
title: 'ユーザーごとの入庫用アドレスを生成する'
emoji: '🐊'
type: 'tech' # tech: 技術記事 / idea: アイデア
topics: [bip32, bip39, bip44, ethereum]
published: true
publication_name: 'synschismo_inc'
---

# 単純に作るだけなら

ユーザー毎のウォレットアドレスを単純に作るだけなら、ethersでも使って以下のようにすればいいでしょう。

```ts
import { Wallet } from 'ethers';

const wallet = Wallet.createRandom();
```

しかし、これだと管理が面倒です。もしDBレコードの作成などに失敗したらそのアドレスは永久に失われてしまいます。

同じindexから常に同じアドレスが生成されるとかだといいですね。

## 決定的アドレス生成

ランダムな生成では、確実に記録しておかないとすぐに値が散逸してしまいます。
同じ入力からいつでも同じように（決定的に）アドレスを生成できるのが理想です。

実は、たった1文のニーモニック（mnemonic）フレーズさえあれば、それを元に決定的にアドレスを生成できます。

これも生成するだけなら簡単で、viemでもethersでも少しのコードで実現できます。

```ts
import { mnemonicToAccount } from 'viem/accounts';
import { HDNodeWallet } from 'ethers';

const mnemonic = process.env.MNEMONIC!;
const n = 100;

for (let i = 0; i < n; i++) {
  const viem = mnemonicToAccount(mnemonic, { accountIndex: i }).address;
  const ethers = HDNodeWallet.fromPhrase(mnemonic, undefined, `m/44'/60'/${i}'/0/0`).address;
}
```

ただ単にユーザーごとのアドレスを用意するだけならこれで十分ですが、成り立ちを理解しておくことが大事です。

# 関連するBIP

上記の決定的アドレス生成に関して、関連するBIPをいくつか紹介します。

- BIP-32: 階層的決定性鍵
- BIP-39: ニーモニック
- BIP-44: パス構造の標準

BIPはBitcoin Improvement Proposalの略で、Bitcoinのプロポーザルを指します。
BIPはBitcoinのプロトコルの改善提案ですが、chain agnosticなものについては他のブロックチェーンでも広くされています。

## BIP-32: 階層的決定性鍵

HDKey (階層的決定性鍵 - Hierarchical Deterministic Key) は、BIP-32で定義された鍵管理システムです。

- 単一のシードから複数の鍵を生成可能
- 公開鍵からさらに公開鍵を導出可能（ハード化されていない場合）

詳細は後述しますが、たとえば先程のコードで指定していた `m/44'/60'/${i}'/0/0`のような階層的なパスでアドレスを管理できます。

シードは一般的に「Mnemonic（ニーモニック、BIP-39）」から生成されます。

## BIP-39: ニーモニック

ニーモニックはBIP-39で定義されており、具体的には以下のような英単語の羅列です。

```
mansion board shell peasant slush arrive insane organ power horse code glide
```

これは完全に出鱈目な英単語の羅列というわけではなく、前提として特定のビット表現に対応した単語リストが定められています。
その単語リストから規定の個数をランダムピックして所定のビット長に変換できるようにしてあるものをニーモニックフレーズと呼んでいます。

viemで生成する例を挙げておきます。

```ts
import { english, generateMnemonic } from 'viem/accounts';
const mnemonic = generateMnemonic(english);
```

https://viem.sh/docs/accounts/local/mnemonicToAccount

## BIP-44: パス構造の標準

BIP-44は、BIP-32のパス構造の標準を定めています。

> We define the following 5 levels in BIP32 path:
>
> ```
> m / purpose' / coin_type' / account' / change / address_index
> ```

https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki

たとえば、Ethereumだと`m/44'/60'/0'`です。

### `0`と`0'`の違い

パスの数字末尾に`'`がつくと**ハード化**を意味します（ちなみに別領域から輸入したなどの由来は特にない記法のようです）。

ハード化すると親の公開鍵から子の公開鍵を派生できません。子の生成に秘密鍵を使用するためです。

ハード化する場合、つまり生成の際に親の秘密鍵を必要とする場合は、index指定を2^32以上の範囲にすることが定められています。

これを簡素に記述するため、`x' = 0x80000000 + x`という記法を用います。

### Bitcoin以外の通貨

SLIP-44（Simple Ledger Improvement Proposal）でBitcoin以外の通過についても番号が定義されています。

https://github.com/satoshilabs/slips/blob/master/slip-0044.md

# Ethereumアドレスへの変換

BIPはあくまでBitcoin用のアドレス生成を定義しているため、Ethereumでは、BIPで定義された鍵からアドレスを導出するための独自の処理が加わります。

前提として、BitcoinでもEthereumでもsecp256k1の楕円曲線上の座標が公開鍵に相当します。
まず、楕円曲線上での座標表現について圧縮形式と非圧縮形式があることを押さえましょう。

Bitcoinのアドレスは非圧縮形式そのままであり、Ethereumのアドレスは非圧縮形式を所定の方法で圧縮したものです。
このときの圧縮は、secp256k1の圧縮形式とはまた異なる処理であるということに注意が必要です。

## 非圧縮形式

secp256k1はその名の通り256ビットのため、座標は256ビット（＝32バイト）です。

prefix`04`に座標(x, y)を32バイトずつ、そのまま繋げた形式を非圧縮形式と呼んでいます。

## 圧縮形式

prefix`02`あるいは`03`にxのみを繋げた形式を圧縮形式と呼んでいます。

x座標が決まると楕円曲線上のy座標は2通りに定まるため、yの偶奇で`02`か`03`かを決定します。

あとは楕円曲線の式からyを求めれば座標（≒非圧縮形式）に戻せます。

## Ethereumのアドレス形式

非圧縮形式のprefix`04`を除いた64バイトをkeccak256にかけて、下位20バイトを抜き出すとEthereumアドレスになります。

つまり、より小さい空間への射となるため非可逆圧縮（衝突があり得る）ですが、十分にsparseであり安全性は問題ないとされています。

# 運用上の意思決定ポイント

## あとから秘密鍵が必要か

以下のようなケースでは、`Wallet.createRandom()`で生成したアドレスをDBレコードに記録しておけばいいでしょう。

- 本当に入庫するだけ、中に入った資産は一切操作しないため**秘密鍵はそもそも不要**
- サーバーサイドですら秘密鍵は絶対に扱いたくない
- 事前にアドレスを生成しておくのではなく、ユーザー生成時に都度アドレスも生成したい

## サーバーサイドで秘密鍵を扱うことを許容するか

基本的にすべてのアドレスの秘密鍵を生成できるニーモニックはサーバーサイドのメモリ上にすら展開したくない代物です。
まったく資産性のないアイテムを扱うようなサービスであれば、あるいはサーバーサイドに展開しておくことも許容できるかもしれません。

- サーバーサイドでニーモニックをメモリ内に展開するか
- ニーモニックはコールドに管理し、ホットには個別のアドレスに対する秘密鍵のみを展開するか
- 個別アドレスに対する秘密鍵もコールドに管理するか

基本的に秘密鍵をホットな環境に一切展開したくないですが、展開せざるを得ないようなユースケースも存在します。
たとえば、ユーザーの操作に応じてサーバーで自動で入庫用アドレス内の資産を操作することが必要な場合などがそうです。

## アカウント別のアドレスをハード化するか

ハード化しない場合、以下のセットが流出したときに一定階層以下の秘密鍵がすべて流出します。

- 分岐の根（親）となる公開鍵
- 分岐の葉（子）のうち、いずれかの秘密鍵

これは、ハード化されていない子の秘密鍵$k_{child}$が、以下のような式で親の公開鍵$K_{parent}$と秘密鍵$k_{parent}$から計算できるためです。

$$
k_{child} = k_{parent} + H(K_{parent}) \mod n
$$

上記の式を見ていくと、流出した値から親の秘密鍵を逆算できることがわかります。

- $H$はハッシュ関数であり、$H(K_{parent})$は流出が仮定された$K_{parent}$から計算できます
- $k_{child}$はそれ自体が流出しているという仮定をおいています

したがって、以下の式で親の秘密鍵を求めることができ、芋づる式に他の子の秘密鍵もすべて手に入ります。

$$
k_{parent} = k_{child} - H(K_{parent}) \mod n
$$

その代わり、公開アドレスの生成には一切の秘密鍵が必要ありません。
つまりサーバーサイドに親の公開鍵のみをおいて子のアドレスを逐次生成することができます。

ここに一定のトレードオフがあります。

- ハード化しない場合
  - 入庫のみで資産操作しないのではあれば、アドレス生成でも秘密鍵を一切扱う必要がない
  - アドレス逐次生成に向くが、子の秘密鍵を万が一にでも流出させるとリスクがかなり大きい
- ハード化する場合
  - アドレス生成時にルートの秘密鍵が必要なため、コールド環境で大量に事前生成する必要がある
  - 子の秘密鍵が漏洩してもそのアドレス以下のみの被害にとどめられる

安全側に振るのであれば、コールド環境で公開アドレスをバッチで大量生成しておき、ユーザーを後から割り当てるという手法が良さそうです。

## アカウントごとのアドレスは不要か

アカウントごとには不要で、サーバーサイドでの受付用ウォレットが1つあればよいというケースでは、クラウドのKMSを利用してそもそも秘密鍵を持たずに署名機能のみ得るという手法が妥当かもしれません。

階層型ウォレットではどうしても秘密鍵それ自体が必要となりますが、単独ウォレットで署名ができれば問題ないというケースではクラウドのKMSが利用できます。

ただし、サービスとして一般的には1キーあたり月$1程度が相場のため、ユーザー全員にKMSを割り当てるという手法は経済的に成り立たないケースが多いと思われます。

# おまけ：viemでのパス指定

ethersでは、パスを直接指定するしか方法がないですが、viemではBIP-44に則って各種indexを引数で受け取ってくれるので便利です。

```ts
// どちらも同じアドレスを生成する

mnemonicToAccount(mnemonic, {
  accountIndex: 0,
  changeIndex: 0,
  addressIndex: 0,
});

mnemonicToAccount(mnemonic, { path: `m/44'/60'/0'/0/0` });
```
