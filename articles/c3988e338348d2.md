---
title: 'Garbled circuitを理解する'
emoji: '💎'
type: 'tech' # tech: 技術記事 / idea: アイデア
topics: [Garbled circuit, MPC, 秘密計算, Yao's Millionaires' Problem]
published: false
---

# Yao's Millionaires' Problem

https://en.wikipedia.org/wiki/Yao%27s_Millionaires%27_problem

1982年に提唱された有名な秘密計算の問題です。

> 2人の富豪がいて、お互いの財産額を開示することなく、どちらの財産がより多いかを知るにはどうすればよいか？

この問題への解決策の1つがGarbled circuitです。

# Garbled circuitとは

これはMPC（Multi-Party Computation）の限定的なケース、2-Party Computationでのプロトコルです。

このプロトコルは大小問題に限らず論理回路$f(x,y)$について、互いに入力値を知ることなく結果を得ることができます。

今回は$f(x, y) = x > y$のケースを考えてみましょう。

まず、論理回路を考えます。

2つの数値の大小は、最上位のbitから順に見ていって、最初にbitの異なるものを見つければ判定できます。

たとえば5と7であれば、2bit目が異なるため、より大きい数値は7であることが分かります。

```
5: 0101
7: 0111
     ^
```

これを漸化式にすると、i番目のbitについて$gt_i(x, y)$は以下のように定義できます：

$$
gt_i(x, y) =
\begin{cases}
(x_i \land \lnot y_i) \lor ((x_i = y_i) \land gt_{i+1}(x, y)) & \text{if } i < n \\
0 & \text{if } i = n
\end{cases}
$$

ここで$x_i$と$y_i$はそれぞれ$x$と$y$の$i$番目のbitを表します。$i=0$は最上位bitを意味します。

# Garbled circuitのプロトコル

Garbled circuitのプロトコルは主に以下のステップから構成されます：

1. **回路のガーブル化（Garbling）**: Aliceが論理回路$f$をガーブル化します
2. **秘密入力の転送**: 暗号化された入力値をBobに転送します
3. **ガーブル回路の評価**: Bobがガーブル回路を評価して結果を得ます

## 1. 回路のガーブル化

回路のガーブル化では、各論理ゲート（AND, OR, XORなど）の真理値表を暗号化します。具体的には：

1. 各ワイヤー（入出力線）に0と1を表す二つのランダムなラベル（例：$k_0^w$, $k_1^w$）を割り当てます
2. 各ゲートの出力テーブルを作成し、暗号化します

例えば、ANDゲートの場合：

| 入力1 | 入力2 | 出力 |
| ----- | ----- | ---- |
| 0     | 0     | 0    |
| 0     | 1     | 0    |
| 1     | 0     | 0    |
| 1     | 1     | 1    |

この真理値表を暗号化すると、以下のようなガーブル化テーブルになります：

| エントリー | 暗号化された値             |
| ---------- | -------------------------- |
| 1          | $Enc(k_0^a, k_0^b, k_0^c)$ |
| 2          | $Enc(k_0^a, k_1^b, k_0^c)$ |
| 3          | $Enc(k_1^a, k_0^b, k_0^c)$ |
| 4          | $Enc(k_1^a, k_1^b, k_1^c)$ |

ここで$k_i^j$はワイヤー$j$の値$i$に対応するラベルです。

## 2. 秘密入力の転送

Aliceは自分の入力$x$に対応するラベルを直接Bobに送ります。
Bobの入力$y$については、Oblivious Transfer（OT）プロトコルを使用します：

1. Bobは各入力ビット$y_i$について、対応するラベル$k_{y_i}^{y_i}$を知りたい
2. Aliceはラベルのペア$(k_0^{y_i}, k_1^{y_i})$を持っている
3. OTプロトコルにより、Bobは$k_{y_i}^{y_i}$のみを受け取り、Aliceは$y_i$の値を知ることなく転送できる

## 3. ガーブル回路の評価

Bobは以下のステップでガーブル回路を評価します：

1. 入力ワイヤーのラベルを使用して、最初のゲートから評価を開始
2. 各ゲートでは、入力ラベルを使って正しい出力ラベルを復号
3. 最終的に出力ゲートのラベルを得て、それを元の値（0または1）に変換

# 具体例：2ビット整数の比較

2ビット整数$x = (x_0, x_1)$と$y = (y_0, y_1)$の比較を考えてみましょう。
$x > y$かどうかを判定する論理式は：

$$
(x_0 \land \lnot y_0) \lor ((x_0 = y_0) \land (x_1 \land \lnot y_1))
$$

これをゲートレベルで表現すると：

1. $g_1 = x_0 \land \lnot y_0$ (ANDゲート)
2. $g_2 = x_0 \oplus y_0$ (XORゲート)
3. $g_3 = \lnot g_2$ (NOTゲート)
4. $g_4 = x_1 \land \lnot y_1$ (ANDゲート)
5. $g_5 = g_3 \land g_4$ (ANDゲート)
6. $g_6 = g_1 \lor g_5$ (ORゲート)

Aliceがこの回路をガーブル化し、OTを通じてBobに必要なラベルを転送します。
Bobは回路を評価して最終的な結果（$x > y$か否か）を得ることができます。

# セキュリティの考察

Garbled circuitは以下の特性を持ちます：

1. **入力の秘匿性**: AliceはBobの入力を知ることができず、BobもAliceの入力を知ることができません
2. **計算の正確性**: 正しい結果が得られることが保証されます
3. **半正直モデル（Semi-Honest Model）**: プロトコルに従う限り安全性が保証されます

しかし、Bobがガーブル回路全体を受け取るため、Aliceが悪意を持って不正な回路を構築する可能性があります。これに対処するには「カット・アンド・チューズ」などの追加的な検証メカニズムが必要です。

# 応用例

Garbled circuitは様々な秘密計算に応用できます：

- プライバシーを保護したデータ分析
- 秘密情報を用いた認証
- プライバシーを保護した機械学習
- ブロックチェーンでのスマートコントラクト

# 結論

Garbled circuitは、お互いの入力を開示することなく共同計算を行うための強力なツールです。実装の複雑さや計算・通信コストの高さが課題ですが、プライバシー保護が重要な多くの応用において有用な技術です。

最近では効率化のための様々な手法（Free XORやHalf AND）が開発され、実用的なアプリケーションへの応用が進んでいます。
